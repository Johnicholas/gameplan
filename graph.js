// Generated by CoffeeScript 1.6.1
var canvas, ctx, diagram, distBetween, draw, drawGrid, drawnLayers, gridSize, hovered, index, mouse, nearestGridPointTo, options_ui, place, run, run_indicator, running, saved_state, select, selected, selectedShape, setShape, shapeAt, stop, toolbar, ui, ui_root, views,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __slice = [].slice;

canvas = document.getElementsByTagName('canvas')[0];

canvas.width = 801;

canvas.height = 601;

drawnLayers = ['nodes', 'arrowLine', 'glow', 'controlPoints'];

ctx = canvas.getContext('2d');

selected = null;

selectedShape = null;

hovered = null;

index = new BBTree();

setShape = function(node, shape) {
  shape.layer = 'nodes';
  shape.cachePos(node.p);
  index.insert(shape);
  node.shape = shape;
  return shape.owner = node;
};

views = [];

Pool.prototype.addView = function(x, y) {
  this.p = v(x, y);
  setShape(this, circle(0, 0, 20));
  return views.push(this);
};

Pool.prototype.moveBy = Gate.prototype.moveBy = function(delta) {
  var arr, _i, _j, _len, _len1, _ref, _ref1, _results;
  this.p = v.add(this.p, delta);
  this.shape.cachePos(this.p);
  _ref = this.out_arrows;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    arr = _ref[_i];
    arr.updateSegments();
  }
  _ref1 = this.in_arrows;
  _results = [];
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    arr = _ref1[_j];
    _results.push(arr.updateSegments());
  }
  return _results;
};

Pool.prototype.moveTo = Gate.prototype.moveTo = function(pos) {
  var delta;
  delta = v.sub(pos, this.p);
  return this.moveBy(delta);
};

Pool.prototype.removeView = Gate.prototype.removeView = function() {
  var arr, _i, _j, _len, _len1, _ref, _ref1;
  _ref = this.out_arrows;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    arr = _ref[_i];
    arr.removeView();
  }
  _ref1 = this.in_arrows;
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    arr = _ref1[_j];
    arr.removeView();
  }
  index.remove(this.shape);
  views.setRemove(this);
  if (this === hovered) {
    hovered = null;
  }
  if (this === selected) {
    return select(null);
  }
};

Pool.prototype.draw = {
  nodes: function() {
    if (this === hovered || this === selected) {
      this.shape.path();
      ctx.strokeStyle = this === selected ? 'hsl(192,77%,48%)' : 'orange';
      ctx.lineWidth = 8;
      ctx.lineJoin = 'round';
      ctx.stroke();
    }
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';
    this.shape.draw();
    ctx.font = '30px IsoEur';
    ctx.fillStyle = 'black';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    return ctx.fillText(this.tokens, this.p.x, this.p.y);
  }
};

Gate.prototype.addView = function(x, y) {
  this.p = v(x, y);
  setShape(this, poly(0, 0, [-20, 0, 0, 20, 20, 0, 0, -20]));
  return views.push(this);
};

Gate.prototype.draw = {
  nodes: function() {
    if (this === hovered || this === selected) {
      this.shape.path();
      ctx.strokeStyle = this === selected ? 'hsl(192,77%,48%)' : 'orange';
      ctx.lineWidth = 8;
      ctx.lineJoin = 'round';
      ctx.stroke();
    }
    ctx.fillStyle = 'white';
    return this.shape.draw();
  }
};

Arrow.prototype.makeSegment = function() {
  var shape;
  shape = segment(0, 0, 0, 0, 6);
  shape.layer = 'arrowLine';
  shape.owner = this;
  return index.insert(shape);
};

Arrow.prototype.addView = function() {
  this.controlPoints = [this.src, this.dst];
  this.shapes = [this.makeSegment()];
  this.updateSegments();
  return views.push(this);
};

Arrow.prototype.removeView = function() {
  var c, i, s, _i, _j, _len, _len1, _ref, _ref1;
  if (this.controlPoints.length > 2 && this === selected && selectedShape.layer === 'controlPoints') {
    i = this.cpShapes.indexOf(selectedShape);
    if (i === 0) {
      this.setSrc(null);
    }
    if (i === this.controlPoints.length - 1) {
      this.setDst(null);
    }
    if (i < this.shapes.length - 1) {
      index.remove(this.shapes[i]);
      this.shapes.splice(i, 1);
    } else {
      index.remove(this.shapes[this.shapes.length - 1]);
      this.shapes.splice(-1, 1);
    }
    if (this.cpShapes) {
      index.remove(this.cpShapes[i]);
      this.cpShapes.splice(i, 1);
    }
    this.controlPoints.splice(i, 1);
    return this.updateSegments();
  } else {
    _ref = this.shapes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      s = _ref[_i];
      index.remove(s);
    }
    if (this.cpShapes) {
      _ref1 = this.cpShapes;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        c = _ref1[_j];
        index.remove(c);
      }
    }
    this.cpShapes = null;
    views.setRemove(this);
    if (this === hovered) {
      hovered = null;
    }
    if (this === selected) {
      return select(null);
    }
  }
};

Arrow.prototype.makeControlPoint = function(p) {
  var s;
  s = circle(0, 0, 4);
  s.layer = 'controlPoints';
  s.cachePos(p);
  s.owner = this;
  return index.insert(s);
};

Arrow.prototype.select = function() {
  var c;
  return this.cpShapes = (function() {
    var _i, _len, _ref, _results;
    _ref = this.controlPoints;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      _results.push(this.makeControlPoint(c.p));
    }
    return _results;
  }).call(this);
};

Arrow.prototype.deselect = function() {
  var s, _i, _len, _ref;
  if (this.cpShapes) {
    _ref = this.cpShapes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      s = _ref[_i];
      index.remove(s);
    }
  }
  return this.cpShapes = null;
};

Arrow.prototype.moveControlPointTo = function(p) {
  var i, target;
  i = this.cpShapes.indexOf(selectedShape);
  target = null;
  index.pointQuery(p, function(s) {
    if (s.layer !== 'nodes') {
      return;
    }
    if (s.pointQuery(mouse)) {
      return target = s.owner;
    }
  });
  hovered = target;
  if (target) {
    this.controlPoints[i] = target;
  } else {
    this.controlPoints[i] = {
      p: p,
      floating: true
    };
  }
  if (i === 0) {
    this.setSrc(target);
  }
  if (i === this.controlPoints.length - 1) {
    this.setDst(target);
  }
  return this.updateSegments();
};

Arrow.prototype.moveTo = function(p) {
  if (selectedShape.layer !== 'controlPoints') {
    return;
  }
  return this.moveControlPointTo(p);
};

Arrow.prototype.moveBy = function(delta) {
  var c, p, _i, _len, _ref;
  if (selectedShape.layer === 'controlPoints') {
    p = v(mouse.x, mouse.y);
    return this.moveControlPointTo(p);
  } else if (selectedShape.layer === 'arrowLine') {
    _ref = this.controlPoints;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      if (c.floating) {
        c.p = v.add(c.p, delta);
      }
    }
    return this.updateSegments();
  }
};

distBetween = function(a, b, x) {
  var delta;
  delta = v.sub(b, a);
  return v.dot(delta, v.sub(x, a)) / v.lensq(delta);
};

Arrow.prototype.doubleClicked = function(mouse) {
  var i;
  if (selectedShape.layer !== 'arrowLine') {
    return;
  }
  i = this.shapes.indexOf(selectedShape);
  this.controlPoints.splice(i + 1, 0, {
    p: mouse,
    floating: true
  });
  this.cpShapes.splice(i + 1, 0, this.makeControlPoint(mouse));
  this.shapes.splice(i + 1, 0, this.makeSegment());
  this.updateSegments();
  selectedShape = this.cpShapes[i + 1];
  return draw();
};

Arrow.prototype.updateSegments = function() {
  var dir, dp, from, i, q, s, shape, sp, to, _i, _j, _len, _len1, _ref, _ref1, _results;
  _ref = this.shapes;
  for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
    shape = _ref[i];
    from = this.controlPoints[i];
    to = this.controlPoints[i + 1];
    sp = from.p;
    dp = to.p;
    shape.a = from.shape && (q = from.shape.segmentQuery(dp, sp)) ? (dir = v.normalize(v.sub(dp, sp)), v.add(v.mult(dir, 6), v.lerp(dp, sp, q.t))) : sp;
    shape.b = to.shape && (q = to.shape.segmentQuery(sp, dp)) ? (dir = v.normalize(v.sub(sp, dp)), v.add(v.mult(dir, 6), v.lerp(sp, dp, q.t))) : dp;
    shape.cachePos();
  }
  if (this.cpShapes) {
    _ref1 = this.cpShapes;
    _results = [];
    for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
      s = _ref1[i];
      _results.push(s.cachePos(this.controlPoints[i].p));
    }
    return _results;
  }
};

Arrow.prototype.strokeArrow = function() {
  var a, b, last, left, n, right, shape, _i, _len, _ref;
  ctx.beginPath();
  ctx.moveTo(this.shapes[0].ta.x, this.shapes[0].ta.y);
  _ref = this.shapes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    shape = _ref[_i];
    ctx.lineTo(shape.tb.x, shape.tb.y);
  }
  last = this.shapes[this.shapes.length - 1];
  a = last.ta;
  b = last.tb;
  n = v.normalize(v.sub(a, b));
  left = v.add(b, v.mult(v.rotate(n, v.forangle(Math.PI / 4)), 6));
  right = v.add(b, v.mult(v.rotate(n, v.forangle(-Math.PI / 4)), 6));
  ctx.moveTo(left.x, left.y);
  ctx.lineTo(b.x, b.y);
  ctx.lineTo(right.x, right.y);
  return ctx.stroke();
};

Arrow.prototype.draw = {
  arrowLine: function() {
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    if (this === hovered || this === selected) {
      ctx.strokeStyle = this === selected ? 'hsl(192,77%,48%)' : 'orange';
      ctx.lineWidth = 5;
      this.strokeArrow();
    }
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
    return this.strokeArrow();
  },
  glow: function() {
    var cp, i, _i, _len, _ref;
    if (this !== selected) {
      return;
    }
    ctx.lineWidth = 10;
    ctx.lineCap = 'round';
    ctx.beginPath();
    _ref = this.controlPoints;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      cp = _ref[i];
      if (i === 0) {
        ctx.moveTo(cp.p.x, cp.p.y);
      } else {
        ctx.lineTo(cp.p.x, cp.p.y);
      }
    }
    ctx.strokeStyle = 'hsla(192,77%,48%,0.2)';
    return ctx.stroke();
  },
  controlPoints: function() {
    var cp, _i, _len, _ref, _results;
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = 'red';
    if (this.cpShapes) {
      _ref = this.cpShapes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        cp = _ref[_i];
        ctx.fillStyle = cp === selectedShape ? 'red' : 'white';
        cp.path();
        ctx.fill();
        _results.push(ctx.stroke());
      }
      return _results;
    }
  }
};

diagram = new Diagram;

(function() {
  var a, d, g, p1, p2;
  d = diagram;
  p1 = d.add(new Pool(2));
  p1.mode = 'push';
  p1.addView(100, 100);
  p2 = d.add(new Pool(0));
  p2.addView(400, 300);
  p2.mode = 'push';
  g = d.add(new Gate);
  g.addView(300, 300);
  a = d.add(new Arrow(p1, g));
  a.addView();
  a = d.add(new Arrow(g, p2));
  a.addView();
  a = d.add(new Arrow(p2, p1));
  return a.addView();
})();

gridSize = 40;

nearestGridPointTo = function(vect) {
  return v(Math.round(vect.x / gridSize * 2) * gridSize / 2, Math.round(vect.y / gridSize * 2) * gridSize / 2);
};

drawGrid = function() {
  var x, y, _i, _j, _ref, _ref1;
  ctx.beginPath();
  for (y = _i = 1, _ref = (canvas.height / gridSize) | 0; 1 <= _ref ? _i < _ref : _i > _ref; y = 1 <= _ref ? ++_i : --_i) {
    ctx.moveTo(0, y * gridSize + 0.5);
    ctx.lineTo(canvas.width - 1, y * gridSize + 0.5);
  }
  for (x = _j = 1, _ref1 = (canvas.width / gridSize) | 0; 1 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 1 <= _ref1 ? ++_j : --_j) {
    ctx.moveTo(x * gridSize + 0.5, 0);
    ctx.lineTo(x * gridSize + 0.5, canvas.height - 1);
  }
  ctx.strokeStyle = 'hsl(205,77%,76%)';
  ctx.lineWidth = 0.5;
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(canvas.width, 0);
  ctx.lineTo(canvas.width, canvas.height);
  ctx.lineTo(0, canvas.height);
  ctx.closePath();
  ctx.lineWidth = 2;
  ctx.stroke();
  return ctx.lineWidth = 1;
};

draw = function() {
  var d, drawfn, l, layer, layers, v, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
  index.reindex();
  ctx.fillStyle = running ? 'hsl(205,74%,97%)' : 'white';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  drawGrid();
  layers = {};
  for (_i = 0, _len = views.length; _i < _len; _i++) {
    v = views[_i];
    _ref = v.draw;
    for (layer in _ref) {
      drawfn = _ref[layer];
      (layers[layer] || (layers[layer] = [])).push([v, drawfn]);
    }
  }
  for (_j = 0, _len1 = drawnLayers.length; _j < _len1; _j++) {
    layer = drawnLayers[_j];
    _ref1 = layers[layer];
    for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
      _ref2 = _ref1[_k], v = _ref2[0], d = _ref2[1];
      d.call(v);
    }
  }
  _results = [];
  for (l in layers) {
    if (__indexOf.call(drawnLayers, l) < 0) {
      _results.push(console.warn("not drawing " + l));
    }
  }
  return _results;
};

setTimeout(function() {
  return draw();
}, 50);

ui_root = document.getElementById('ui-root');

options_ui = null;

select = function(o, s) {
  var new_options_ui;
  if (o === selected) {
    selectedShape = s;
  } else {
    if (selected != null) {
      if (typeof selected.deselect === "function") {
        selected.deselect();
      }
    }
    selected = o;
    selectedShape = s;
    if (selected != null) {
      if (typeof selected.select === "function") {
        selected.select();
      }
    }
    if (selected) {
      new_options_ui = makeOptionsUIFor(selected);
      ui_root.appendChild(new_options_ui.el);
      setTimeout(function() {
        return new_options_ui.animateIn();
      }, 0);
      if (options_ui) {
        options_ui.animateOut();
      }
      options_ui = new_options_ui;
    } else {
      if (options_ui) {
        options_ui.animateOut();
        options_ui = null;
      }
    }
  }
  return draw();
};

shapeAt = function(mouse) {
  var result, resultLayerId;
  result = null;
  resultLayerId = -1;
  index.pointQuery(mouse, function(s) {
    var layerId;
    if (!s.layer) {
      return console.error("shape " + s + " does not have a layer");
    }
    layerId = drawnLayers.indexOf(s.layer);
    if (layerId === -1) {
      return console.error("unknown layer " + s.layer);
    }
    if (resultLayerId < layerId && s.pointQuery(mouse)) {
      result = s;
      return resultLayerId = layerId;
    }
  });
  return result;
};

running = false;

saved_state = null;

mouse = v(0, 0);

run_indicator = ui_root.appendChild(tag('div'));

style(run_indicator, {
  position: 'absolute',
  left: '5px',
  bottom: '5px',
  transition: '150ms',
  border: '5px solid red',
  borderRadius: '10px',
  opacity: '0'
});

run_indicator.animateIn = function() {
  return style(run_indicator, {
    opacity: '1'
  });
};

run_indicator.animateOut = function() {
  return style(run_indicator, {
    opacity: '0'
  });
};

toolbar = ui_root.appendChild(makeToolbar());

style(toolbar, {
  transition: '150ms'
});

toolbar.appendChild(makePlaceButton('pool')).onclick = function() {
  return place('pool', this);
};

toolbar.appendChild(makePlaceButton('gate')).onclick = function() {
  return place('gate', this);
};

toolbar.appendChild(makePlaceButton('arrow')).onclick = function() {
  return place('arrow', this);
};

toolbar.animateOut = function() {
  return style(this, {
    opacity: '0',
    bottom: '-20px'
  });
};

toolbar.animateIn = function() {
  return style(this, {
    opacity: '1',
    bottom: '0px'
  });
};

place = function(type, button) {
  if (ui.state === ui.placing) {
    ui.pop();
  }
  return ui.push(ui.placing, type, button);
};

run = function() {
  running = true;
  hovered = null;
  selected = null;
  if (options_ui != null) {
    options_ui.animateOut();
  }
  options_ui = null;
  ui.push(ui.running);
  run_indicator.animateIn();
  toolbar.animateOut();
  return draw();
};

stop = function() {
  running = false;
  diagram.restore(saved_state);
  ui.pop();
  run_indicator.animateOut();
  toolbar.animateIn();
  return draw();
};

ui = {
  states: [],
  state: null,
  push: function() {
    var args, state, _base;
    state = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    this.states.push(this.state);
    this.state = state;
    return typeof (_base = this.state).enter === "function" ? _base.enter.apply(_base, args) : void 0;
  },
  pop: function() {
    var _base;
    if (typeof (_base = this.state).leave === "function") {
      _base.leave();
    }
    return this.state = this.states.pop();
  }
};

ui["default"] = {
  mousemove: function(e) {
    var o, s;
    s = shapeAt(mouse);
    o = s != null ? s.owner : void 0;
    if (hovered !== o) {
      hovered = o;
      return draw();
    }
  },
  mousedown: function(e) {
    var s, _base;
    s = shapeAt(mouse);
    if (s) {
      ui.push(ui.dragging, s.owner, s);
      return typeof (_base = ui.dragging).mousedown === "function" ? _base.mousedown(e) : void 0;
    } else {
      return select(null);
    }
  },
  keydown: function(e) {
    switch (e.which) {
      case 32:
        e.preventDefault();
        saved_state = diagram.state();
        return run();
      case 8:
        e.preventDefault();
        if (selected != null) {
          selected.removeView();
        }
        return draw();
    }
  }
};

ui.dragging = {
  enter: function(object, shape) {
    this.object = object;
    this.shape = shape;
    this.dragPos = mouse;
    select(this.object, this.shape);
    return canvas.style.cursor = 'move';
  },
  mousedown: function(e) {
    var _base;
    if (e.detail === 2) {
      return typeof (_base = this.object).doubleClicked === "function" ? _base.doubleClicked(mouse) : void 0;
    }
  },
  mousemove: function(e) {
    var delta, _base, _base1;
    delta = v.sub(mouse, this.dragPos);
    this.dragPos = mouse;
    if (e.shiftKey) {
      if (typeof (_base = this.object).moveTo === "function") {
        _base.moveTo(nearestGridPointTo(mouse));
      }
    } else {
      if (typeof (_base1 = this.object).moveBy === "function") {
        _base1.moveBy(delta);
      }
    }
    return draw();
  },
  mouseup: function(e) {
    canvas.style.cursor = '';
    return ui.pop();
  }
};

ui.placing = {
  enter: function(type, button) {
    this.type = type;
    this.button = button;
    return this.button.style.boxShadow = '0px 0px 4px red';
  },
  leave: function() {
    return this.button.style.boxShadow = 'initial';
  },
  mousedown: function(e) {
    var a, p, s, src;
    if (this.type === 'pool') {
      p = diagram.add(new Pool);
      p.addView(mouse.x, mouse.y);
      ui.pop();
      ui.push(ui.dragging, p);
    } else if (this.type === 'gate') {
      p = diagram.add(new Gate);
      p.addView(mouse.x, mouse.y);
      ui.pop();
      ui.push(ui.dragging, p);
    } else if (this.type === 'arrow') {
      if (s = shapeAt(mouse)) {
        src = s.owner;
      } else {
        src = {
          p: v(mouse.x, mouse.y),
          floating: true
        };
      }
      a = diagram.add(new Arrow(src, {
        p: v(mouse.x, mouse.y),
        floating: true
      }));
      a.addView();
      ui.pop();
      select(a);
      ui.push(ui.dragging, a, a.cpShapes[1]);
      a;
    }
    return draw();
  }
};

ui.running = {
  mousedown: function(e) {
    var s, _base;
    s = shapeAt(mouse);
    if (s) {
      if (typeof (_base = s.owner).activate === "function") {
        _base.activate();
      }
      return draw();
    }
  },
  keydown: function(e) {
    if (e.which === 32) {
      e.preventDefault();
      return stop();
    }
  }
};

ui.push(ui["default"]);

canvas.addEventListener('mousedown', function(e) {
  var _base;
  mouse = v(e.offsetX, e.offsetY);
  if (typeof (_base = ui.state).mousedown === "function") {
    _base.mousedown(e);
  }
  return false;
});

window.addEventListener('mouseup', function(e) {
  var _base;
  if (typeof (_base = ui.state).mouseup === "function") {
    _base.mouseup(e);
  }
  return false;
});

canvas.addEventListener('mousemove', function(e) {
  var _base;
  mouse = v(e.offsetX, e.offsetY);
  if (typeof (_base = ui.state).mousemove === "function") {
    _base.mousemove(e);
  }
  return false;
});

window.addEventListener('keydown', function(e) {
  var _base;
  if (document.activeElement.tagName === 'INPUT') {
    return;
  }
  if (typeof (_base = ui.state).keydown === "function") {
    _base.keydown(e);
  }
  return false;
});

window.addEventListener('keyup', function(e) {
  var _base;
  if (document.activeElement.tagName === 'INPUT') {
    return;
  }
  if (typeof (_base = ui.state).keyup === "function") {
    _base.keyup(e);
  }
  return false;
});

/*

dragMousePos = null

mouse = null
canvas.addEventListener 'mousemove', (e) ->
  mouse = v e.offsetX, e.offsetY
  if dragged
    delta = v.sub mouse, dragMousePos
    dragMousePos = mouse

    dragged.moveBy delta

    draw()


  else
    newHover = objectAt mouse

    if hovered != newHover
      hovered = newHover
      draw()

nextMouseUp = null

saved_state = null
window.addEventListener 'keydown', (e) ->
  switch String.fromCharCode e.which
    when " "
      e.preventDefault()
      if running
        diagram.restore saved_state
      else
        saved_state = diagram.state()
      draw()
      running = not running
    when "P"
      break if running
      p = diagram.add new Pool
      p.addView mouse.x, mouse.y
      draw()
      dragged = p
      dragMousePos = mouse
    when "A"
      break if running
      nextMouseUp = ->
        o = objectAt mouse
        a = diagram.add new Arrow o, {p:v(mouse.x,mouse.y), in_arrows:[]}
        a.addView()
        dragged = a
        dragMousePos = mouse
        a.moveBy = (delta) ->
          a.shape.b.x += delta.x
          a.shape.b.y += delta.y
          a.shape.recalcNormal()
          a.shape.cachePos()
        nextMouseUp = try_end = ->
          if o = objectAt mouse
            a.dst = o
            o.in_arrows.push a
            a.shape.b = o.p
            a.shape.recalcNormal()
            a.shape.cachePos()
            draw()
            dragged = null
          else
            nextMouseUp = try_end

canvas.addEventListener 'mousedown', (e) ->
  mouse = v e.offsetX, e.offsetY
  dragged = hover = objectAt mouse
  dragged = null if dragged instanceof Arrow
  if running
    if dragged
      dragged.activate?()
      draw()
    dragged = null
  dragMousePos = mouse

canvas.addEventListener 'mouseup', (e) ->
  if f = nextMouseUp
    nextMouseUp = null
    f()
    return
  dragged = null
*/

