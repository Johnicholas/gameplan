// Generated by CoffeeScript 1.6.1
var Contact, NONE, Vect, circle2circleQuery, containsVert, containsVertPartial, exports, findMSA, findPointsBehindSeg, findVerts, findVertsFallback, last_MSA_min, max, min, segValueOnAxis, valueOnAxis;

min = Math.min;

max = Math.max;

Vect = v.Vect;

exports = window;

Contact = function(p, n, dist) {
  this.p = p;
  this.n = n;
  this.dist = dist;
  this.r1 = this.r2 = v.zero;
  this.nMass = this.tMass = this.bounce = this.bias = 0;
  return this.jnAcc = this.jtAcc = this.jBias = 0;
};

NONE = [];

circle2circleQuery = function(p1, p2, r1, r2) {
  var delta, dist, distsq, mindist;
  mindist = r1 + r2;
  delta = v.sub(p2, p1);
  distsq = v.lensq(delta);
  if (distsq >= mindist * mindist) {
    return;
  }
  dist = Math.sqrt(distsq);
  return new Contact(v.add(p1, v.mult(delta, 0.5 + (r1 - 0.5 * mindist) / (dist != null ? dist : {
    dist: Infinity
  }))), (dist ? v.mult(delta, 1 / dist) : new Vect(1, 0)), dist - mindist);
};

exports.circle2circle = function(circ1, circ2) {
  var contact;
  contact = circle2circleQuery(circ1.tc, circ2.tc, circ1.r, circ2.r);
  if (contact) {
    return [contact];
  } else {
    return NONE;
  }
};

exports.circle2segment = function(circleShape, segmentShape) {
  var center, closest, closest_t, contact, seg_a, seg_b, seg_delta;
  seg_a = segmentShape.ta;
  seg_b = segmentShape.tb;
  center = circleShape.tc;
  seg_delta = v.sub(seg_b, seg_a);
  closest_t = v.clamp01(v.dot(seg_delta, v.sub(center, seg_a)) / v.lensq(seg_delta));
  closest = v.add(seg_a, v.mult(seg_delta, closest_t));
  contact = circle2circleQuery(center, closest, circleShape.r, segmentShape.r);
  if (contact) {
    return [contact];
  } else {
    return NONE;
  }
};

valueOnAxis = function(poly, n, d) {
  var i, m, tVerts, _i, _ref;
  tVerts = poly.tVerts;
  m = v.dot2(n.x, n.y, tVerts[0], tVerts[1]);
  for (i = _i = 2, _ref = tVerts.length; _i < _ref; i = _i += 2) {
    m = min(m, v.dot2(n.x, n.y, tVerts[i], tVerts[i + 1]));
  }
  return m - d;
};

containsVert = function(poly, vx, vy) {
  var dist, i, n, tAxes, _i, _ref;
  tAxes = poly.tAxes;
  for (i = _i = 0, _ref = tAxes.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    n = tAxes[i].n;
    dist = v.dot2(n.x, n.y, vx, vy) - tAxes[i].d;
    if (dist > 0) {
      return false;
    }
  }
  return true;
};

containsVertPartial = function(poly, vx, vy, n) {
  var dist, i, n2, tAxes, _i, _ref;
  tAxes = poly.tAxes;
  for (i = _i = 0, _ref = tAxes.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    n2 = tAxes[i].n;
    if (v.dot(n2, n) < 0) {
      continue;
    }
    dist = v.dot2(n2.x, n2.y, vx, vy) - tAxes[i].d;
    if (dist > 0) {
      return false;
    }
  }
  return true;
};

last_MSA_min = 0;

findMSA = function(poly, axes) {
  var dist, i, min_index, msa_min, _i, _ref;
  min_index = 0;
  msa_min = valueOnAxis(poly, axes[0].n, axes[0].d);
  if (msa_min > 0) {
    return -1;
  }
  for (i = _i = 1, _ref = axes.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
    dist = valueOnAxis(poly, axes[i].n, axes[i].d);
    if (dist > 0) {
      return -1;
    }
    if (dist > msa_min) {
      msa_min = dist;
      min_index = i;
    }
  }
  last_MSA_min = msa_min;
  return min_index;
};

findVertsFallback = function(poly1, poly2, n, dist) {
  var arr, i, verts1, verts2, vx, vy, _i, _j, _ref, _ref1;
  arr = [];
  verts1 = poly1.tVerts;
  for (i = _i = 0, _ref = verts1.length; _i < _ref; i = _i += 2) {
    vx = verts1[i];
    vy = verts1[i + 1];
    if (containsVertPartial(poly2, vx, vy, v.neg(n))) {
      arr.push(new Contact(new Vect(vx, vy), n, dist));
    }
  }
  verts2 = poly2.tVerts;
  for (i = _j = 0, _ref1 = verts2.length; _j < _ref1; i = _j += 2) {
    vx = verts2[i];
    vy = verts2[i + 1];
    if (containsVertPartial(poly1, vx, vy, n)) {
      arr.push(new Contact(new Vect(vx, vy), n, dist));
    }
  }
  return arr;
};

findVerts = function(poly1, poly2, n, dist) {
  var arr, i, verts1, verts2, vx, vy, _i, _j, _ref, _ref1;
  arr = [];
  verts1 = poly1.tVerts;
  for (i = _i = 0, _ref = verts1.length; _i < _ref; i = _i += 2) {
    vx = verts1[i];
    vy = verts1[i + 1];
    if (containsVert(poly2, vx, vy)) {
      arr.push(new Contact(new Vect(vx, vy), n, dist));
    }
  }
  verts2 = poly2.tVerts;
  for (i = _j = 0, _ref1 = verts2.length; _j < _ref1; i = _j += 2) {
    vx = verts2[i];
    vy = verts2[i + 1];
    if (containsVert(poly1, vx, vy)) {
      arr.push(new Contact(new Vect(vx, vy), n, dist));
    }
  }
  if (arr.length) {
    return arr;
  } else {
    return findVertsFallback(poly1, poly2, n, dist);
  }
};

exports.poly2poly = function(poly1, poly2) {
  var min1, min2, mini1, mini2;
  mini1 = findMSA(poly2, poly1.tAxes);
  if (mini1 === -1) {
    return NONE;
  }
  min1 = last_MSA_min;
  mini2 = findMSA(poly1, poly2.tAxes);
  if (mini2 === -1) {
    return NONE;
  }
  min2 = last_MSA_min;
  if (min1 > min2) {
    return findVerts(poly1, poly2, poly1.tAxes[mini1].n, min1);
  } else {
    return findVerts(poly1, poly2, v.neg(poly2.tAxes[mini2].n), min2);
  }
};

segValueOnAxis = function(seg, n, d) {
  var a, b;
  a = v.dot(n, seg.ta) - seg.r;
  b = v.dot(n, seg.tb) - seg.r;
  return min(a, b) - d;
};

findPointsBehindSeg = function(arr, seg, poly, pDist, coef) {
  var dt, dta, dtb, i, n, verts, vx, vy, _i, _ref;
  dta = v.cross(seg.tn, seg.ta);
  dtb = v.cross(seg.tn, seg.tb);
  n = v.mult(seg.tn, coef);
  verts = poly.tVerts;
  for (i = _i = 0, _ref = verts.length; _i < _ref; i = _i += 2) {
    vx = verts[i];
    vy = verts[i + 1];
    if (v.dot2(vx, vy, n.x, n.y) < v.dot(seg.tn, seg.ta) * coef + seg.r) {
      dt = v.cross2(seg.tn.x, seg.tn.y, vx, vy);
      if (dta >= dt && dt >= dtb) {
        arr.push(new Contact(new Vect(vx, vy), n, pDist));
      }
    }
  }
};

exports.segment2poly = function(seg, poly) {
  var arr, axes, con, dist, i, len, minNeg, minNorm, mini, mini2, numVerts, poly_a, poly_b, poly_min, poly_n, segD, va, vb, verts, _i;
  arr = [];
  axes = poly.tAxes;
  numVerts = axes.length;
  segD = v.dot(seg.tn, seg.ta);
  minNorm = valueOnAxis(poly, seg.tn, segD) - seg.r;
  minNeg = valueOnAxis(poly, v.neg(seg.tn), -segD) - seg.r;
  if (minNeg > 0 || minNorm > 0) {
    return NONE;
  }
  mini = 0;
  poly_min = segValueOnAxis(seg, axes[0].n, axes[0].d);
  if (poly_min > 0) {
    return NONE;
  }
  for (i = _i = 0; 0 <= numVerts ? _i < numVerts : _i > numVerts; i = 0 <= numVerts ? ++_i : --_i) {
    dist = segValueOnAxis(seg, axes[i].n, axes[i].d);
    if (dist > 0) {
      return NONE;
    } else if (dist > poly_min) {
      poly_min = dist;
      mini = i;
    }
  }
  poly_n = v.neg(axes[mini].n);
  va = v.add(seg.ta, v.mult(poly_n, seg.r));
  vb = v.add(seg.tb, v.mult(poly_n, seg.r));
  if (containsVert(poly, va.x, va.y)) {
    arr.push(new Contact(va, poly_n, poly_min));
  }
  if (containsVert(poly, vb.x, vb.y)) {
    arr.push(new Contact(vb, poly_n, poly_min));
  }
  if (minNorm >= poly_min || minNeg >= poly_min) {
    if (minNorm > minNeg) {
      findPointsBehindSeg(arr, seg, poly, minNorm, 1);
    } else {
      findPointsBehindSeg(arr, seg, poly, minNeg, -1);
    }
  }
  if (arr.length === 0) {
    mini2 = mini * 2;
    verts = poly.tVerts;
    poly_a = new Vect(verts[mini2], verts[mini2 + 1]);
    if ((con = circle2circleQuery(seg.ta, poly_a, seg.r, 0, arr))) {
      return [con];
    }
    if ((con = circle2circleQuery(seg.tb, poly_a, seg.r, 0, arr))) {
      return [con];
    }
    len = numVerts * 2;
    poly_b = new Vect(verts[(mini2 + 2) % len], verts[(mini2 + 3) % len]);
    if ((con = circle2circleQuery(seg.ta, poly_b, seg.r, 0, arr))) {
      return [con];
    }
    if ((con = circle2circleQuery(seg.tb, poly_b, seg.r, 0, arr))) {
      return [con];
    }
  }
  return arr;
};

exports.circle2poly = function(circ, poly) {
  var axes, con, dist, dt, dta, dtb, i, least, len, mini, mini2, n, verts, x1, x2, y1, y2, _i, _ref;
  axes = poly.tAxes;
  mini = 0;
  least = v.dot(axes[0].n, circ.tc) - axes[0].d - circ.r;
  for (i = _i = 0, _ref = axes.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    dist = v.dot(axes[i].n, circ.tc) - axes[i].d - circ.r;
    if (dist > 0) {
      return NONE;
    } else if (dist > least) {
      least = dist;
      mini = i;
    }
  }
  n = axes[mini].n;
  verts = poly.tVerts;
  len = verts.length;
  mini2 = mini << 1;
  x1 = verts[mini2];
  y1 = verts[mini2 + 1];
  x2 = verts[(mini2 + 2) % len];
  y2 = verts[(mini2 + 3) % len];
  dta = v.cross2(n.x, n.y, x1, y1);
  dtb = v.cross2(n.x, n.y, x2, y2);
  dt = v.cross(n, circ.tc);
  if (dt < dtb) {
    con = circle2circleQuery(circ.tc, new Vect(x2, y2), circ.r, 0, con);
    if (con) {
      return [con];
    } else {
      return NONE;
    }
  } else if (dt < dta) {
    return [new Contact(v.sub(circ.tc, v.mult(n, circ.r + least / 2)), v.neg(n), least)];
  } else {
    con = circle2circleQuery(circ.tc, new Vect(x1, y1), circ.r, 0, con);
    if (con) {
      return [con];
    } else {
      return NONE;
    }
  }
};
