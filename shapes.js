// Generated by CoffeeScript 1.6.1
var Axis, bbContainsVect2, circleSegmentQuery, max, min, poly, polyValidate, setAxes, setupPoly, swap, transformAxes, transformVerts, v;

if (typeof window === "undefined" || window === null) {
  v = require('./vect');
}

min = Math.min;

max = Math.max;

circleSegmentQuery = function(shape, center, r, a, b) {
  var det, qa, qb, qc, t;
  a = v.sub(a, center);
  b = v.sub(b, center);
  qa = v.dot(a, a) - 2 * v.dot(a, b) + v.dot(b, b);
  qb = -2 * v.dot(a, a) + 2 * v.dot(a, b);
  qc = v.dot(a, a) - r * r;
  det = qb * qb - 4 * qa * qc;
  if (det >= 0) {
    t = (-qb - Math.sqrt(det)) / (2 * qa);
    if ((0 <= t && t <= 1)) {
      return {
        shape: shape,
        t: t,
        n: v.normalize(v.lerp(a, b, t))
      };
    }
  }
};

exports.Circle = (function() {

  Circle.prototype.type = 'circle';

  function Circle(x, y, radius) {
    if (typeof x !== 'number') {
      throw new error('need an x');
    }
    if (typeof y !== 'number') {
      throw new error('need a y');
    }
    if (typeof radius !== 'number') {
      throw new error('need a radius');
    }
    this.c = v(x, y);
    this.tc = null;
    this.r = radius;
  }

  Circle.prototype.cachePos = function(tpos, trot) {
    var c;
    c = this.c;
    if (trot) {
      c = v.rotate(c, trot);
    }
    if (tpos) {
      c = v.add(tpos, c);
    }
    this.tc = c;
    this.bb_l = this.tc.x - this.r;
    this.bb_r = this.tc.x + this.r;
    this.bb_b = this.tc.y - this.r;
    this.bb_t = this.tc.y + this.r;
    return this;
  };

  Circle.prototype.path = function() {
    ctx.beginPath();
    return ctx.arc(this.tc.x, this.tc.y, this.r, 0, 2 * Math.PI, false);
  };

  Circle.prototype.draw = function() {
    this.path();
    ctx.lineWidth = 2;
    ctx.fill();
    return ctx.stroke();
  };

  Circle.prototype.pointQuery = function(p) {
    var delta, dist, distsq;
    delta = v.sub(p, this.tc);
    distsq = v.lensq(delta);
    if (distsq < this.r * this.r) {
      dist = Math.sqrt(distsq);
      return {
        shape: this,
        d: this.r - dist,
        n: v.mult(delta, 1 / dist)
      };
    }
  };

  Circle.prototype.segmentQuery = function(a, b) {
    return circleSegmentQuery(this, this.tc, this.r, a, b);
  };

  Circle.prototype.toJSON = function() {
    return {
      type: this.type,
      c: this.c,
      r: this.r
    };
  };

  return Circle;

})();

exports.circle = function(x, y, r) {
  return new exports.Circle(x, y, r);
};

bbContainsVect2 = function(l, b, r, t, v) {
  return l <= v.x && r >= v.x && b <= v.y && t >= v.y;
};

exports.Segment = (function() {

  Segment.prototype.type = 'segment';

  function Segment(x1, y1, x2, y2, r) {
    this.r = r;
    this.a = v(x1, y1);
    this.b = v(x2, y2);
    this.n = v.perp(v.normalize(v.sub(this.b, this.a)));
  }

  Segment.prototype.cachePos = function(tpos, trot) {
    var b, l, r, t;
    this.n = v.perp(v.normalize(v.sub(this.b, this.a)));
    if (tpos == null) {
      tpos = v.zero;
    }
    this.ta = v.add(tpos, (trot ? v.rotate(this.a, trot) : this.a));
    this.tb = v.add(tpos, (trot ? v.rotate(this.b, trot) : this.b));
    this.tn = trot ? v.rotate(this.n, trot) : this.n;
    if (this.ta.x < this.tb.x) {
      l = this.ta.x;
      r = this.tb.x;
    } else {
      l = this.tb.x;
      r = this.ta.x;
    }
    if (this.ta.y < this.tb.y) {
      b = this.ta.y;
      t = this.tb.y;
    } else {
      b = this.tb.y;
      t = this.ta.y;
    }
    this.bb_l = l - this.r;
    this.bb_b = b - this.r;
    this.bb_r = r + this.r;
    this.bb_t = t + this.r;
    return this;
  };

  Segment.prototype.draw = function() {
    ctx.lineCap = 'round';
    ctx.lineWidth = max(1, this.r * 2);
    ctx.beginPath();
    ctx.moveTo(this.ta.x, this.ta.y);
    ctx.lineTo(this.tb.x, this.tb.y);
    return ctx.stroke();
  };

  Segment.prototype.pointQuery = function(p) {
    var a, b, closest, closest_t, delta, dist, distsq, seg_delta;
    if (!bbContainsVect2(this.bb_l, this.bb_b, this.bb_r, this.bb_t, p)) {
      return;
    }
    a = this.ta;
    b = this.tb;
    seg_delta = v.sub(b, a);
    closest_t = v.clamp01(v.dot(seg_delta, v.sub(p, a)) / v.lensq(seg_delta));
    closest = v.add(a, v.mult(seg_delta, closest_t));
    delta = v.sub(p, closest);
    distsq = v.lensq(delta);
    if (distsq < this.r * this.r) {
      dist = Math.sqrt(distsq);
      return {
        shape: this,
        d: this.r - dist,
        n: v.mult(delta, 1 / dist)
      };
    }
  };

  Segment.prototype.segmentQuery = function(a, b) {
    var ad, bd, d, d_offset, delta, flipped_n, info1, info2, n_offset, seg_a, seg_b;
    d = v.dot(v.sub(this.ta, a), this.tn);
    flipped_n = d > 0 ? v.neg(this.tn) : this.tn;
    n_offset = v.sub(v.mult(flipped_n, this.r), a);
    seg_a = v.add(this.ta, n_offset);
    seg_b = v.add(this.tb, n_offset);
    delta = v.sub(b, a);
    if (v.cross(delta, seg_a) * v.cross(delta, seg_b) <= 0) {
      d_offset = d + (d > 0 ? -this.r : this.r);
      ad = -d_offset;
      bd = v.dot(delta, this.tn) - d_offset;
      if (ad * bd < 0) {
        return {
          shape: this,
          t: ad / (ad - bd),
          n: flipped_n
        };
      }
    } else if (this.r !== 0) {
      info1 = circleSegmentQuery(this, this.ta, this.r, a, b);
      info2 = circleSegmentQuery(this, this.tb, this.r, a, b);
      if (info1) {
        if (info2 && info2.t < info1.t) {
          return info2;
        } else {
          return info1;
        }
      } else {
        return info2;
      }
    }
  };

  return Segment;

})();

exports.segment = function(x1, y1, x2, y2, r) {
  return new exports.Segment(x1, y1, x2, y2, r);
};

Axis = function(n, d) {
  this.n = n;
  this.d = d;
};

polyValidate = function(verts) {
  var i, len, x1, x2, x3, y1, y2, y3, _i;
  len = verts.length;
  for (i = _i = 0; _i < len; i = _i += 2) {
    x1 = verts[i];
    y1 = verts[i + 1];
    x2 = verts[(i + 2) % len];
    y2 = verts[(i + 3) % len];
    x3 = verts[(i + 4) % len];
    y3 = verts[(i + 5) % len];
    if (vcross2(x2 - x1, y2 - y1, x3 - x2, y3 - y2) > 0) {
      return false;
    }
  }
  return true;
};

setAxes = function(poly) {
  var d, i, len, n, numVerts, verts, x1, x2, y1, y2;
  verts = poly.verts;
  len = verts.length;
  numVerts = len >> 1;
  return poly.axes = (function() {
    var _i, _results;
    _results = [];
    for (i = _i = 0; _i < len; i = _i += 2) {
      x1 = verts[i];
      y1 = verts[i + 1];
      x2 = verts[(i + 2) % len];
      y2 = verts[(i + 3) % len];
      n = v.normalize(v(y1 - y2, x2 - x1));
      d = v.dot2(n.x, n.y, x1, y1);
      _results.push(new Axis(n, d));
    }
    return _results;
  })();
};

setupPoly = function(poly) {
  if (!polyValidate(poly)) {
    throw new Error('points must be clockwise');
  }
  setAxes(poly);
  poly.tVerts = new Array(poly.verts.length);
  return poly.tAxes = (function() {
    var _i, _ref, _results;
    _results = [];
    for (_i = 0, _ref = poly.axes.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--) {
      _results.push(new Axis(v.zero, 0));
    }
    return _results;
  })();
};

transformVerts = function(poly, p, rot) {
  var b, dst, i, l, r, src, t, vx, vy, x, y, _i, _ref;
  src = poly.verts;
  dst = poly.tVerts;
  l = Infinity;
  r = -Infinity;
  b = Infinity;
  t = -Infinity;
  for (i = _i = 0, _ref = src.length; _i < _ref; i = _i += 2) {
    x = src[i];
    y = src[i + 1];
    if (rot != null) {
      vx = p.x + x * rot.x - y * rot.y;
      vy = p.y + x * rot.y + y * rot.x;
    } else {
      vx = p.x + x;
      vy = p.y + y;
    }
    dst[i] = vx;
    dst[i + 1] = vy;
    l = min(l, vx);
    r = max(r, vx);
    b = min(b, vy);
    t = max(t, vy);
  }
  poly.bb_l = l;
  poly.bb_b = b;
  poly.bb_r = r;
  return poly.bb_t = t;
};

transformAxes = function(poly, p, rot) {
  var dst, i, n, src, _i, _ref, _results;
  src = poly.axes;
  dst = poly.tAxes;
  _results = [];
  for (i = _i = 0, _ref = src.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    n = rot != null ? v.rotate(src[i].n, rot) : src[i].n;
    dst[i].n = n;
    _results.push(dst[i].d = v.dot(p, n) + src[i].d);
  }
  return _results;
};

exports.Poly = (function() {

  function Poly(x, y, verts) {
    this.verts = verts;
    this.p = v(x, y);
    setupPoly(this);
  }

  Poly.prototype.cachePos = function(tpos, trot) {
    var p;
    if (trot != null) {
      if (typeof trot === 'number') {
        trot = v.forangle(trot);
      }
      p = v.rotate(this.p, trot);
    } else {
      p = this.p;
    }
    if (tpos != null) {
      p = v(tpos.x + p.x, tpos.y + p.y);
    }
    transformVerts(this, p, trot);
    transformAxes(this, p, trot);
    return this;
  };

  Poly.prototype.path = function() {
    var i, len, _i;
    ctx.beginPath();
    len = this.verts.length;
    ctx.moveTo(this.tVerts[0], this.tVerts[1]);
    for (i = _i = 2; _i < len; i = _i += 2) {
      ctx.lineTo(this.tVerts[i], this.tVerts[i + 1]);
    }
    return ctx.closePath();
  };

  Poly.prototype.draw = function() {
    this.path();
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
    ctx.fill();
    return ctx.stroke();
  };

  Poly.prototype.type = 'poly';

  Poly.prototype.pointQuery = function(p) {
    var axes, dist, i, info, n, _i, _ref;
    if (!bbContainsVect2(this.bb_l, this.bb_b, this.bb_r, this.bb_t, p)) {
      return;
    }
    info = {
      shape: this
    };
    axes = this.tAxes;
    for (i = _i = 0, _ref = axes.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      n = axes[i].n;
      dist = axes[i].d - v.dot(n, p);
      if (dist < 0) {
        return;
      } else if (dist < info.d) {
        info.d = dist;
        info.n = n;
      }
    }
    return info;
  };

  Poly.prototype.segmentQuery = function(a, b) {
    var an, axes, bn, dt, dtMax, dtMin, i, len, n, point, t, verts, _i, _ref;
    axes = this.tAxes;
    verts = this.tVerts;
    len = axes.length * 2;
    for (i = _i = 0, _ref = axes.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      n = axes[i].n;
      an = v.dot(a, n);
      if (axes[i].d > an) {
        continue;
      }
      bn = v.dot(b, n);
      t = (axes[i].d - an) / (bn - an);
      if (t < 0 || 1 < t) {
        continue;
      }
      point = v.lerp(a, b, t);
      dt = -v.cross(n, point);
      dtMin = -v.cross2(n.x, n.y, verts[i * 2], verts[i * 2 + 1]);
      dtMax = -v.cross2(n.x, n.y, verts[(i * 2 + 2) % len], verts[(i * 2 + 3) % len]);
      if (dtMin <= dt && dt <= dtMax) {
        return {
          shape: this,
          t: t,
          n: n
        };
      }
    }
  };

  return Poly;

})();

exports.poly = poly = function(x, y, verts) {
  return new exports.Poly(x, y, verts);
};

exports.rect = function(x, y, w, h) {
  return poly(x, y, [0, 0, 0, h, w, h, w, 0]);
};

swap = function(collisions) {
  var c, _i, _len;
  for (_i = 0, _len = collisions.length; _i < _len; _i++) {
    c = collisions[_i];
    c.n.x *= -1;
    c.n.y *= -1;
  }
  return collisions;
};

exports.collide = function(a, b) {
  switch (a.type) {
    case 'circle':
      switch (b.type) {
        case 'circle':
          return circle2circle(a, b);
        case 'poly':
          return circle2poly(a, b);
        case 'segment':
          return circle2segment(a, b);
      }
      break;
    case 'segment':
      switch (b.type) {
        case 'circle':
          return swap(circle2segment(b, a));
        case 'poly':
          return segment2poly(a, b);
        case 'segment':
          return [];
      }
      break;
    case 'poly':
      switch (b.type) {
        case 'circle':
          return swap(circle2poly(b, a));
        case 'poly':
          return poly2poly(a, b);
        case 'segment':
          return swap(segment2poly(b, a));
      }
  }
};
